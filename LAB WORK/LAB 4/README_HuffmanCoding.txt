Huffman Coding Implementation in C (File-Based Frequency Input)
This program implements Huffman Coding, a compression technique that assigns variable‑length binary codes to characters based on their frequency. The program reads a file, counts character frequencies, builds a Huffman tree, and prints the Huffman codes for each character.

Features:
- Reads characters from a file and counts their frequencies.
- Builds a min‑heap of nodes for Huffman tree construction.
- Combines least‑frequent nodes into an optimal prefix tree.
- Prints Huffman codes for every unique character.
- Supports up to 256 ASCII characters.

Functions Implemented:
newNode(data, freq) – creates a new Huffman tree node.
createMinHeap(capacity) – allocates a min‑heap.
swapMinHeapNode(a, b) – swaps two heap nodes.
minHeapify(minHeap, idx) – enforces min‑heap property.
isSizeOne(minHeap) – checks if heap contains a single node.
extractMin(minHeap) – removes the node with smallest frequency.
insertMinHeap(minHeap, node) – inserts a node into the min‑heap.
buildMinHeap(minHeap) – converts array into valid min‑heap.
isLeaf(root) – checks if a node is a leaf.
createAndBuildMinHeap(data, freq, size) – builds initial min‑heap.
buildHuffmanTree(data, freq, size) – constructs full Huffman tree.
printCodes(root, arr, top) – prints codes generated by tree traversal.
HuffmanCodes(data, freq, size) – wrapper to build tree and print codes.
main() – reads file, computes frequency table, filters unique characters, prints Huffman codes.

How It Works:
- File is scanned character by character.
- Frequencies stored in freq[256].
- Only characters with non‑zero frequency are copied into data[] and cleaned frequency array.
- A min‑heap is built where each node contains a character and its frequency.
- Repeatedly extract two minimum nodes and combine them into a new internal node.
- The process repeats until one root remains → the Huffman tree.
- Codes are generated by traversing the tree:
  * Left branch → 0
  * Right branch → 1
- Leaf nodes correspond to actual characters, whose codes are printed.

Notes:
- Huffman coding produces prefix‑free codes (no code is a prefix of another).
- More frequent characters get shorter codes.
- Using a file makes this implementation suitable for text compression demonstrations.
- Internal nodes use data '$' as a placeholder.

Why I Made This:
To understand and practice:
- Huffman coding algorithm and optimal prefix trees.
- Min‑heap operations and priority queue logic.
- File handling and character frequency analysis.
- Constructing and traversing binary trees for data compression.
